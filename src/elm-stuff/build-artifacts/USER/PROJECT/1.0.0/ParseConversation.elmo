Elm.ParseConversation = Elm.ParseConversation || {};
Elm.ParseConversation.make = function (_elm) {
   "use strict";
   _elm.ParseConversation = _elm.ParseConversation || {};
   if (_elm.ParseConversation.values)
   return _elm.ParseConversation.values;
   var _op = {},
   _N = Elm.Native,
   _U = _N.Utils.make(_elm),
   _L = _N.List.make(_elm),
   $moduleName = "ParseConversation",
   $Basics = Elm.Basics.make(_elm),
   $Conversation = Elm.Conversation.make(_elm),
   $Dict = Elm.Dict.make(_elm),
   $Json$Decode = Elm.Json.Decode.make(_elm),
   $List = Elm.List.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $Result = Elm.Result.make(_elm),
   $String = Elm.String.make(_elm);
   var verifyLeadToOneQuestion = function (dict) {
      return function () {
         var errorMessage2 = function (name) {
            return A2($Basics._op["++"],
            "Expecting child \"",
            A2($Basics._op["++"],
            name,
            "\" to not be Questions!"));
         };
         var errorMessage1 = function (name) {
            return A2($Basics._op["++"],
            "Child \"",
            A2($Basics._op["++"],
            name,
            "\" does not map to anything!"));
         };
         var getChildren = function (_v0) {
            return function () {
               switch (_v0.ctor)
               {case "Talking":
                  return _v0._0.children;}
               _U.badCase($moduleName,
               "on line 212, column 13 to 28");
            }();
         };
         var isSpeech = function (node) {
            return function () {
               switch (node.ctor)
               {case "Asking": return false;
                  case "Talking": return true;}
               _U.badCase($moduleName,
               "between lines 206 and 209");
            }();
         };
         var isQuestions = function ($) {
            return $Basics.not(isSpeech($));
         };
         var isChildNotQuestions = F2(function (name,
         dict) {
            return $Maybe.withDefault(false)($Maybe.map(function ($) {
               return $Basics.not(isQuestions($));
            })(A2($Dict.get,name,dict)));
         });
         var check = F2(function (name,
         dict) {
            return A2($Dict.member,
            name,
            dict) ? A2(isChildNotQuestions,
            name,
            dict) ? $Result.Ok(dict) : $Result.Err(errorMessage2(name)) : $Result.Err(errorMessage1(name));
         });
         var foldCheck = F2(function (name,
         rDict) {
            return A2($Result.andThen,
            rDict,
            check(name));
         });
         var speechesWithMultipleChildren = $List.filter(function ($) {
            return function (x) {
               return _U.cmp(x,1) > 0;
            }($List.length(getChildren($)));
         })($List.filter(isSpeech)($Dict.values(dict)));
         var childrenOfSelectedSpeeches = $List.concatMap(getChildren)(speechesWithMultipleChildren);
         return A3($List.foldr,
         foldCheck,
         $Result.Ok(dict),
         childrenOfSelectedSpeeches);
      }();
   };
   var verifyQuestionsLeadToSpeech = function (dict) {
      return function () {
         var errorMessage2 = function (name) {
            return A2($Basics._op["++"],
            "Expecting child \"",
            A2($Basics._op["++"],
            name,
            "\" to be a Speech, not Questions!"));
         };
         var errorMessage1 = function (name) {
            return A2($Basics._op["++"],
            "Child \"",
            A2($Basics._op["++"],
            name,
            "\" does not map to anything!"));
         };
         var getChildren = function (_v6) {
            return function () {
               switch (_v6.ctor)
               {case "Asking":
                  return A2($List.concatMap,
                    function (_) {
                       return _.children;
                    },
                    _v6._0);}
               _U.badCase($moduleName,
               "on line 176, column 13 to 47");
            }();
         };
         var isQuestion = function (node) {
            return function () {
               switch (node.ctor)
               {case "Asking": return true;
                  case "Talking": return false;}
               _U.badCase($moduleName,
               "between lines 170 and 173");
            }();
         };
         var isSpeech = function ($) {
            return $Basics.not(isQuestion($));
         };
         var isChildASpeech = F2(function (name,
         dict) {
            return $Maybe.withDefault(false)($Maybe.map(isSpeech)(A2($Dict.get,
            name,
            dict)));
         });
         var check = F2(function (name,
         dict) {
            return A2($Dict.member,
            name,
            dict) ? A2(isChildASpeech,
            name,
            dict) ? $Result.Ok(dict) : $Result.Err(errorMessage2(name)) : $Result.Err(errorMessage1(name));
         });
         var foldCheck = F2(function (name,
         rDict) {
            return A2($Result.andThen,
            rDict,
            check(name));
         });
         var allQuestions = $List.filter(isQuestion)($Dict.values(dict));
         var allQuestionPaths = A2($List.concatMap,
         getChildren,
         allQuestions);
         return A3($List.foldr,
         foldCheck,
         $Result.Ok(dict),
         allQuestionPaths);
      }();
   };
   var verifyValidNames = function (dict) {
      return function () {
         var intercalate = F2(function (x,
         list) {
            return $String.concat(A2($List.intersperse,
            x,
            list));
         });
         var correctNames = A2($List.foldr,
         F2(function (name,dict) {
            return A3($Dict.insert,
            name,
            {ctor: "_Tuple0"},
            dict);
         }),
         $Dict.empty)(_L.fromArray(["Ava"
                                   ,"Gavin"
                                   ,"Sebastian"
                                   ,"Sophie"]));
         var errorMessage = function (name) {
            return A2($Basics._op["++"],
            "Name \"",
            A2($Basics._op["++"],
            name,
            A2($Basics._op["++"],
            "\" is not one of ",
            A2(intercalate,
            ", ",
            $Dict.keys(correctNames)))));
         };
         var check = F2(function (name,
         dict) {
            return A2($Dict.member,
            name,
            correctNames) ? $Result.Ok(dict) : $Result.Err(errorMessage(name));
         });
         var foldCheck = F2(function (name,
         rDict) {
            return A2($Result.andThen,
            rDict,
            check(name));
         });
         var getName = function (node) {
            return function () {
               switch (node.ctor)
               {case "Asking": return "";
                  case "Talking":
                  return node._0.name;}
               _U.badCase($moduleName,
               "between lines 141 and 144");
            }();
         };
         var names = $List.filter(function ($) {
            return $Basics.not($String.isEmpty($));
         })($List.map(getName)($Dict.values(dict)));
         return A3($List.foldr,
         foldCheck,
         $Result.Ok(dict),
         names);
      }();
   };
   var verifyAllKeysValid = function (dict) {
      return function () {
         var errorMessage = function (name) {
            return A2($Basics._op["++"],
            "Child \"",
            A2($Basics._op["++"],
            name,
            "\" does not map to anything!"));
         };
         var check = F2(function (name,
         dict) {
            return A2($Dict.member,
            name,
            dict) ? $Result.Ok(dict) : $Result.Err(errorMessage(name));
         });
         var foldCheck = F2(function (name,
         rDict) {
            return A2($Result.andThen,
            rDict,
            check(name));
         });
         var getChildren = function (node) {
            return function () {
               switch (node.ctor)
               {case "Asking":
                  return A2($List.concatMap,
                    function (_) {
                       return _.children;
                    },
                    node._0);
                  case "Talking":
                  return node._0.children;}
               _U.badCase($moduleName,
               "between lines 118 and 123");
            }();
         };
         var children = $List.concatMap(getChildren)($Dict.values(dict));
         return A3($List.foldr,
         foldCheck,
         $Result.Ok(dict),
         children);
      }();
   };
   var question = A3($Json$Decode.object2,
   $Conversation.Question,
   A2($Json$Decode._op[":="],
   "text",
   $Json$Decode.list($Json$Decode.string)),
   A2($Json$Decode._op[":="],
   "children",
   $Json$Decode.list($Json$Decode.string)));
   var questions = $Json$Decode.map($Conversation.Asking)($Json$Decode.list(question));
   var speech = $Json$Decode.map($Conversation.Talking)(A4($Json$Decode.object3,
   $Conversation.Speech,
   A2($Json$Decode._op[":="],
   "name",
   $Json$Decode.string),
   A2($Json$Decode._op[":="],
   "text",
   $Json$Decode.list($Json$Decode.string)),
   A2($Json$Decode._op[":="],
   "children",
   $Json$Decode.list($Json$Decode.string))));
   var conversationNode = $Json$Decode.oneOf(_L.fromArray([speech
                                                          ,questions]));
   var conversation = $Json$Decode.dict(conversationNode);
   _elm.ParseConversation.values = {_op: _op
                                   ,speech: speech
                                   ,question: question
                                   ,questions: questions
                                   ,conversationNode: conversationNode
                                   ,conversation: conversation
                                   ,verifyAllKeysValid: verifyAllKeysValid
                                   ,verifyValidNames: verifyValidNames
                                   ,verifyQuestionsLeadToSpeech: verifyQuestionsLeadToSpeech
                                   ,verifyLeadToOneQuestion: verifyLeadToOneQuestion};
   return _elm.ParseConversation.values;
};